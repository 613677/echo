　　//我创建的图是一个无向图，并用邻接矩阵存储结构（它是表示顶点间相关联系的矩阵。）它的特点是：无向图的邻接矩阵对称，可压缩存储；有n个顶点的无向图需存储空间为n(n+1)/2；无向图中顶点Vi的度TD(Vi)是邻接矩阵A中第i行(或第i列)元素之和；
无向图的总边数为非0元素个数的一半；
　　typedef struct      //是用邻接矩阵储存信息的图
　　{
　　	VerType Ver[MaxVer];//顶点集合
　　	int numOfVer;
　　	int edge[MaxVer][MaxVer];
　　	int numOfEdges;
}AdjMWGraph;
　　
　　
　　
　　void CreatGraph(AdjMWGraph *G,VerType Ver[],int vn,int E[][3],int en)//创建图
　　{
　　	int i,k;
　　	InitGraph(G,vn);//生成vn*vn的图
　　	for(i=0;i<vn;i++)
　　	InsertVer(G,Ver[i]);//插入vn个顶点
　　	for(k=0;k<en;k++)
　　	InsertArc(G,E[k][0],E[k][1],E[k][2]);//插入en条边,E[k][0]表示开始的顶点,E[k][1]表示结束的顶点,E[k][2]表示此边的权重即路径的长度
　　}
　　
　　
　　void InitGraph(AdjMWGraph *G,int vn)//初始化
　　{
　　	int i,j;
　　	for(i=0;i<vn;i++)
　　	for(j=0;j<vn;j++)
　　		{
　　			if(i==j) G->edge[i][j]=0;
　　			else G->edge[i][j]=MaxWeight;
　　		}
　　	G->numOfVer=0;	
　　	G->numOfEdges=0;
　　｝
　　
　　
　　
　　void InsertVer(AdjMWGraph *G,VerType cv)//插入顶点
　　{
　　	G->Ver[G->numOfVer]=cv;
　　	G->numOfVer++;
　　}
　　
　　
　　void InsertArc(AdjMWGraph *G,int v1,int v2,int weight)//插入边<v1，v2>，边<v1，v2>的权重为weight
　　{
　　	if(v1<0||v1>G->numOfVer||v2<0||v2>G->numOfVer)
　　	{
　　		printf("参数v1或v2越界出错！\n");
　　		exit(1);
　　	}
　　	G->edge[v1][v2]=weight;
　　	G->numOfEdges++;
　　}
　　
　　
